* Resource Collections					     :@DataType:@Ant:
  A Resource Collection is an abstraction of an entity that groups together a
  number of resources. 

* Path-like Structures					     :@DataType:@Ant:
  /path/ and /classpath/ are used to represent the path concept with "path"
  separated by ":" and ";". 

  You may consider them as a container of pathes represent an /path/ that may be
  used in other places. There are several different ways to specify elements
  inside a /path/ container:
  1. Nested /pathelement/ element.
     There are two attribute for an /pathelement/ element: "path" attribute
     contains a string with pathes that separated by delimiter; "location"
     attribute that contains a specific location. Location could be a
     directory or file.
  2. Resource Collections that contains only file-type resources could be
     specified inside /path/. Common used resource collections includes
     /fileset/, /dirset/, /filelist/.
  3. Reference to another path-like structure via nested /<path>/ element.

* if/unless attribute for target				 :@Task:@Ant:
    A target has the ability to perform its execution if(or unless) a property
    has been set. For example:
#+BEGIN_SRC nxml
  <target name="java-env-check" unless="env.JAVA_HOME">
    <fail message="JAVA_HOME environment variables must be set."/>
  </target>
#+END_SRC
    This example will fail the building unless /JAVA_HOME/ environment variable
    has been set.

* @Stateless Annotation 					      :@EJB3:
  @Stateless annotation marks a stateless session bean. This means that the
  container automatically provides such services to the bean as :
  1. automatic concurrency control. (will create thread for each request to the
     session bean?)
  2. thread safety
  3. pooling
  4. transaction management. (How?)

* The whole point of building server-side application		      :@EJB3:
The *whole point* of building server-side application is that they can be shared
by a large number of remote clients at the same time. 

Because session beans are specifically meant to handle client requests, they
must support a high degree of concurrency safely and rebostly. 

* AOP								       :@AOP:
  AOP is the ability to isolate "crosscutting" concerns into their own modules and
  apply them across the application through configuration.

* The anatomy of session bean					      :@EJB3:
  Each session bean implementation has two distinct parts -- one or more bean
  interface and a bean implementation class. This is because clients cannot have
  access to the bean implementation class directly. Instead they must use
  session beans through a business interface. 

* Stateful and Stateless					      :@EJB3:
  As youâ€™ll soon see, however, this does not mean that stateless session beans
  cannot have instance variables. Even before we explore any code, common sense
  should tell us that session beans must cache some resources, like database
  connec- tions, for performance reasons. The critical distinction here is
  client expectations.  As long as the client does not need to depend on the
  fact that a session bean uses instance variables to maintain conversational
  state, there is no need to use a state- ful session bean.


* Life cycle callback methods					      :@EJB3:

  | Callback Annotation            | Type of EJB              | Used For ...                                  |
  |--------------------------------+--------------------------+-----------------------------------------------|
  | javax.annotation.Postconstruct | stateless, stateful, MDB | initialize resources                          |
  | javax.annotation.PreDestroy    | stateless, stateful, MDB | clean up resources                            |
  | javax.ejb.PrePassivate         | stateful                 | clean up resources that can not be serialized |
  | javax.ejb.PostActivate         | stateful                 | restore resources                             |

* Web Service Endpoint Interface				      :@EJB3:
  Web service endpoint interface is known as SEI. The ability to expose a
  stateless session bean as a SOAP-based web service is one of the most powerful
  features of EJB 3. All you need to do to make a bean SOAP accessible is mark a
  business interface with the @javax.jws.WebService annotation.

* Multiple Business Interface					      :@EJB3:
  Although it is tempting, but you *cannot* mark the same interface with more
  than one access type annotation, then interface could be either @Local,
  @Remote, or @WebService.

* Inject EJB to other tiers					      :@EJB3:
  It is legal to inject stateful session bean to another stateful session bean
  and the injected EJB will be automatically removed when the EJB contains it is
  removed.

  But you must not inject a stateful session bean into a stateless object, such
  as a stateless session bean or servlet that may be shared by multiple
  concurrent clients. 

* Passivating and Removing beans				      :@EJB3:
  The rules for passivation are generally implementation specific. Improper use
  of passivation policies(when passivition configuration is an option) may cause
  performance problems. You have to check the documentation for your EJB
  container and appropriately set passivation rules.

* The role of Messaging						       :@JMS:
  - Messaging is widely used to solve reliability and scalability issues.
  - Heterogeneous integration is one primary area where messaging plays a key role.
* The advantage of messaging					       :@JMS:
  - heterogeneous integration 
  - reduce system bottlenecks
  - increase scalability
  - increase end user productivity
  - architecture flexibility and agility

* Two kinds of messaging
  1. Point-to-Point
     The point-to-point messaging model allows JMS clients to send and receive
     messages both synchronously and asynchronously via virtual channels known
     as queues. The point-to-point messaging model has traditionally been a
     pull-based or polling-based model, where messages are requested from the
     queue instead of being pushed to the client automatically.
  2. Publish-and-Subscribe
     In the publish-and-subscribe model, messages are published to a virtual
     channel called a topic. Unlike the point-to-point model, message published
     to a topic using the publish-and-subscribe model can be received by
     multiple subscribers. The publish-and-subscribe messaging model is by and
     large a push-based model, where message are automatically broadcast to
     consumers without them having to request or poll the topic for new
     messages.

* JMS session
  In JMS, the Session object holds the transactional unit of work for messaging,
  not the Connection object. This is different from JDBC, where the Connection
  object holds the transactional unit of work. This means that when using JMS,
  an application will typically have only a single /Connection/ object but will
  have a pool of /Session/ objects.

* Service-Oriented Architecture					       :@SOA:
  Service-Oriented Architecture(SOA) describes an architecture style that
  defines business services that are abstracted from the corresponding
  enterprise service implementations. SOA has given rise to a new breed of
  middleware known as an Enterprise Service Bus, or ESB.

* RPC								       :@RPC:
  RPC attempts to mimic the behavior of a system that runs in one process. When
  a remote procedure is invoked, the caller is blocked until the procedure
  completes ans returns control to the caller. The synchronized nature of RPC
  tightly couples the client to the server.

  It is the synchronized, tightly coupled, interdependent nature of RPC systems
  that cause entire systems to fail as a result of failures in subsystems. 

* MDB best practice						      :@EJB3:
  - Choose your messaging models carefully. 
    You might find that PTP will solve your problem nine times out of ten. But
    for some broadcasting cases, pub-sub model would be appropriate.

  - Remember modularization
    Business logic should be decoupled and modularized away from
    messaging-specific concerns. An excellect practice is to put business logic
    in session beans and invoke them from the /onMessage/ method.

  - Make good use of message filter

  - Choose message types carefully
    to XML or not XML

  - Be wary of poison message

  - Configure MDB pool size
* EJB Proxy							       :EJB3:
  The container makes beans "special" by acting as a proxy between the client
  and the actual bean instance. This enables the container to provide EJB
  services to the client on behalf of the bean instance. 

  For each bean instance, the container automatically generates a proxy called
  an /EJB object/. The EJB object has access to all the functionality of the
  container, including the JNDI registry, security, transaction management,
  thread pools, session management, and pretty much anything else that is
  necessary to provide EJB service.

* Setter Injection						      :@EJB3:
  Other than field injection, you may also use setter injection that provide
  injeciton on a setter method. In this way, Injection will happen to the
  paramter of setter method. There are two benifits according to "EJB 3 in
  Action":
  
  1. It is easier to unit-test by invoking the public setter method from a
     testing framework.

  2. It is easier to put initialization code in the setter method.

* Multiple interceptors, multi-level interceptors		      :@EJB3:
  If you specified default, class-, and method-level interceptor, then they will
  be executed in the order:

  Default Interceptor -> Class Interceptor -> Method Interceptor

  If more than one interceptor is applied at any given level, then they are
  executed in the order which they are specified.

  The only way to alter this execution order is to use the /interceptor-order/
  element in the deployment descriptor; there are no annotation for changing
  interceptor order. 

* Disable interceptor						      :@EJB3:
  - /@javax.interceptor.ExcludeDefaultInterceptor/ annotation ::
    disable default interceptor.

  - /@javax.interceptor.ExcludeClassInterceptor/ annotation ::
    disable class interceptor.

* Interceptor and Exceptions
  If a business method interceptor throws an exception before invoking the
  proceed method, the processing of other interceptors in the invocation chain
  and the target business method will be terminated.

* Lifecycle callback methods in the interceptor class
  Lifecycle callback defined in an interceptor class are known as /lifecycle
  callback interceptors/ or /lifecycle callback listeners/. When the target bean
  transition lifecycles, annotated methods in the interceptor class are
  triggered.

  Note that a bean can have the same lifecycle callbacks both in the bean itself
  as well as in one or more interceptors. That is the whole point of calling the
  /InvocationContext.proceed/ method in lifecycle interceptor methods as in the
  resource logger code.

* Timers
  EJB 3 timer service allows you to specify a method that is automatically
  invoked after a specified interval of time. 

  We can only use timers in stateless session beans and MDBs because their
  asynchronous, stateless nature. However, unlike stateless session bean and
  MDBs, Timers are persistence and can survive a container crash or
  restart. Timers are also *transactional*, that is, a transaction failure in a
  timeout method rolls back the action taken by the timer.

* Transactions
  In the most basic terms, a /transaction/ is a grouping of tasks that must be
  processed as an inseparable unit. 

  In addiion to the *all-or-nothing* value proposition, transaction must
  guarentee a degree of reliability and robustness. 

  A successful transaction is committed, meaning its result are made permanent,
  whereas a failed transaction is rolled back, as if it nerver happened.



* Org Configuration
#+STARTUP: hidestars
#+TAGS: @EJB3 @Ant @AOP
#+TAGS: @DataType @Task
