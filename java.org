* Resource Collections					     :@DataType:@Ant:
  A Resource Collection is an abstraction of an entity that groups together a
  number of resources. 

* Path-like Structures					     :@DataType:@Ant:
  /path/ and /classpath/ are used to represent the path concept with "path"
  separated by ":" and ";". 

  You may consider them as a container of pathes represent an /path/ that may be
  used in other places. There are several different ways to specify elements
  inside a /path/ container:
  1. Nested /pathelement/ element.
     There are two attribute for an /pathelement/ element: "path" attribute
     contains a string with pathes that separated by delimiter; "location"
     attribute that contains a specific location. Location could be a
     directory or file.
  2. Resource Collections that contains only file-type resources could be
     specified inside /path/. Common used resource collections includes
     /fileset/, /dirset/, /filelist/.
  3. Reference to another path-like structure via nested /<path>/ element.

* if/unless attribute for target				 :@Task:@Ant:
    A target has the ability to perform its execution if(or unless) a property
    has been set. For example:
#+BEGIN_SRC nxml
  <target name="java-env-check" unless="env.JAVA_HOME">
    <fail message="JAVA_HOME environment variables must be set."/>
  </target>
#+END_SRC
    This example will fail the building unless /JAVA_HOME/ environment variable
    has been set.

* @Stateless Annotation 					      :@EJB3:
  @Stateless annotation marks a stateless session bean. This means that the
  container automatically provides such services to the bean as :
  1. automatic concurrency control. (will create thread for each request to the
     session bean?)
  2. thread safety
  3. pooling
  4. transaction management. (How?)

* The whole point of building server-side application		      :@EJB3:
The *whole point* of building server-side application is that they can be shared
by a large number of remote clients at the same time. 

Because session beans are specifically meant to handle client requests, they
must support a high degree of concurrency safely and rebostly. 

* AOP								       :@AOP:
  AOP is the ability to isolate "crosscutting" concerns into their own modules and
  apply them across the application through configuration.

* The anatomy of session bean					      :@EJB3:
  Each session bean implementation has two distinct parts -- one or more bean
  interface and a bean implementation class. This is because clients cannot have
  access to the bean implementation class directly. Instead they must use
  session beans through a business interface. 

* Stateful and Stateless					      :@EJB3:
  As youâ€™ll soon see, however, this does not mean that stateless session beans
  cannot have instance variables. Even before we explore any code, common sense
  should tell us that session beans must cache some resources, like database
  connec- tions, for performance reasons. The critical distinction here is
  client expectations.  As long as the client does not need to depend on the
  fact that a session bean uses instance variables to maintain conversational
  state, there is no need to use a state- ful session bean.


* Life cycle callback methods					      :@EJB3:

  | Callback Annotation            | Type of EJB              | Used For ...                                  |
  |--------------------------------+--------------------------+-----------------------------------------------|
  | javax.annotation.Postconstruct | stateless, stateful, MDB | initialize resources                          |
  | javax.annotation.PreDestroy    | stateless, stateful, MDB | clean up resources                            |
  | javax.ejb.PrePassivate         | stateful                 | clean up resources that can not be serialized |
  | javax.ejb.PostActivate         | stateful                 | restore resources                             |

* Web Service Endpoint Interface				      :@EJB3:
  Web service endpoint interface is known as SEI. The ability to expose a
  stateless session bean as a SOAP-based web service is one of the most powerful
  features of EJB 3. All you need to do to make a bean SOAP accessible is mark a
  business interface with the @javax.jws.WebService annotation.

* Multiple Business Interface					      :@EJB3:
  Although it is tempting, but you *cannot* mark the same interface with more
  than one access type annotation, then interface could be either @Local,
  @Remote, or @WebService.

* Inject EJB to other tiers					      :@EJB3:
  It is legal to inject stateful session bean to another stateful session bean
  and the injected EJB will be automatically removed when the EJB contains it is
  removed.

  But you must not inject a stateful session bean into a stateless object, such
  as a stateless session bean or servlet that may be shared by multiple
  concurrent clients. 

* Passivating and Removing beans				      :@EJB3:
  The rules for passivation are generally implementation specific. Improper use
  of passivation policies(when passivition configuration is an option) may cause
  performance problems. You have to check the documentation for your EJB
  container and appropriately set passivation rules.


* Org Configuration
#+STARTUP: hidestars
#+TAGS: @EJB3 @Ant @AOP
#+TAGS: @DataType @Task
