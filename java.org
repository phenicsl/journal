* Resource Collections					     :@DataType:@Ant:
  A Resource Collection is an abstraction of an entity that groups together a
  number of resources. 

* Path-like Structures					     :@DataType:@Ant:
  /path/ and /classpath/ are used to represent the path concept with "path"
  separated by ":" and ";". 

  You may consider them as a container of pathes represent an /path/ that may be
  used in other places. There are several different ways to specify elements
  inside a /path/ container:
  1. Nested /pathelement/ element.
     There are two attribute for an /pathelement/ element: "path" attribute
     contains a string with pathes that separated by delimiter; "location"
     attribute that contains a specific location. Location could be a
     directory or file.
  2. Resource Collections that contains only file-type resources could be
     specified inside /path/. Common used resource collections includes
     /fileset/, /dirset/, /filelist/.
  3. Reference to another path-like structure via nested /<path>/ element.

* if/unless attribute for target				 :@Task:@Ant:
    A target has the ability to perform its execution if(or unless) a property
    has been set. For example:
#+BEGIN_SRC nxml
  <target name="java-env-check" unless="env.JAVA_HOME">
    <fail message="JAVA_HOME environment variables must be set."/>
  </target>
#+END_SRC
    This example will fail the building unless /JAVA_HOME/ environment variable
    has been set.

* @Stateless Annotation 					      :@EJB3:
  @Stateless annotation marks a stateless session bean. This means that the
  container automatically provides such services to the bean as :
  1. automatic concurrency control. (will create thread for each request to the
     session bean?)
  2. thread safety
  3. pooling
  4. transaction management. (How?)

* The whole point of building server-side application		      :@EJB3:
The *whole point* of building server-side application is that they can be shared
by a large number of remote clients at the same time. 

Because session beans are specifically meant to handle client requests, they
must support a high degree of concurrency safely and rebostly. 

* AOP								       :@AOP:
  AOP is the ability to isolate "crosscutting" concerns into their own modules and
  apply them across the application through configuration.

* The anatomy of session bean					      :@EJB3:
  Each session bean implementation has two distinct parts -- one or more bean
  interface and a bean implementation class. This is because clients cannot have
  access to the bean implementation class directly. Instead they must use
  session beans through a business interface. 

* Stateful and Stateless					      :@EJB3:
  As youâ€™ll soon see, however, this does not mean that stateless session beans
  cannot have instance variables. Even before we explore any code, common sense
  should tell us that session beans must cache some resources, like database
  connec- tions, for performance reasons. The critical distinction here is
  client expectations.  As long as the client does not need to depend on the
  fact that a session bean uses instance variables to maintain conversational
  state, there is no need to use a state- ful session bean.


* Life cycle callback methods					      :@EJB3:

  | Callback Annotation            | Type of EJB              | Used For ...                                  |
  |--------------------------------+--------------------------+-----------------------------------------------|
  | javax.annotation.Postconstruct | stateless, stateful, MDB | initialize resources                          |
  | javax.annotation.PreDestroy    | stateless, stateful, MDB | clean up resources                            |
  | javax.ejb.PrePassivate         | stateful                 | clean up resources that can not be serialized |
  | javax.ejb.PostActivate         | stateful                 | restore resources                             |

* Web Service Endpoint Interface				      :@EJB3:
  Web service endpoint interface is known as SEI. The ability to expose a
  stateless session bean as a SOAP-based web service is one of the most powerful
  features of EJB 3. All you need to do to make a bean SOAP accessible is mark a
  business interface with the @javax.jws.WebService annotation.

* Multiple Business Interface					      :@EJB3:
  Although it is tempting, but you *cannot* mark the same interface with more
  than one access type annotation, then interface could be either @Local,
  @Remote, or @WebService.

* Inject EJB to other tiers					      :@EJB3:
  It is legal to inject stateful session bean to another stateful session bean
  and the injected EJB will be automatically removed when the EJB contains it is
  removed.

  But you must not inject a stateful session bean into a stateless object, such
  as a stateless session bean or servlet that may be shared by multiple
  concurrent clients. 

* Passivating and Removing beans				      :@EJB3:
  The rules for passivation are generally implementation specific. Improper use
  of passivation policies(when passivition configuration is an option) may cause
  performance problems. You have to check the documentation for your EJB
  container and appropriately set passivation rules.

* The role of Messaging						       :@JMS:
  - Messaging is widely used to solve reliability and scalability issues.
  - Heterogeneous integration is one primary area where messaging plays a key role.
* The advantage of messaging					       :@JMS:
  - heterogeneous integration 
  - reduce system bottlenecks
  - increase scalability
  - increase end user productivity
  - architecture flexibility and agility

* Two kinds of messaging
  1. Point-to-Point
     The point-to-point messaging model allows JMS clients to send and receive
     messages both synchronously and asynchronously via virtual channels known
     as queues. The point-to-point messaging model has traditionally been a
     pull-based or polling-based model, where messages are requested from the
     queue instead of being pushed to the client automatically.
  2. Publish-and-Subscribe
     In the publish-and-subscribe model, messages are published to a virtual
     channel called a topic. Unlike the point-to-point model, message published
     to a topic using the publish-and-subscribe model can be received by
     multiple subscribers. The publish-and-subscribe messaging model is by and
     large a push-based model, where message are automatically broadcast to
     consumers without them having to request or poll the topic for new
     messages.

* JMS session
  In JMS, the Session object holds the transactional unit of work for messaging,
  not the Connection object. This is different from JDBC, where the Connection
  object holds the transactional unit of work. This means that when using JMS,
  an application will typically have only a single /Connection/ object but will
  have a pool of /Session/ objects.

* Service-Oriented Architecture					       :@SOA:
  Service-Oriented Architecture(SOA) describes an architecture style that
  defines business services that are abstracted from the corresponding
  enterprise service implementations. SOA has given rise to a new breed of
  middleware known as an Enterprise Service Bus, or ESB.

* RPC								       :@RPC:
  RPC attempts to mimic the behavior of a system that runs in one process. When
  a remote procedure is invoked, the caller is blocked until the procedure
  completes ans returns control to the caller. The synchronized nature of RPC
  tightly couples the client to the server.

  It is the synchronized, tightly coupled, interdependent nature of RPC systems
  that cause entire systems to fail as a result of failures in subsystems. 

* MDB best practice						      :@EJB3:
  - Choose your messaging models carefully. 
    You might find that PTP will solve your problem nine times out of ten. But
    for some broadcasting cases, pub-sub model would be appropriate.

  - Remember modularization
    Business logic should be decoupled and modularized away from
    messaging-specific concerns. An excellect practice is to put business logic
    in session beans and invoke them from the /onMessage/ method.

  - Make good use of message filter

  - Choose message types carefully
    to XML or not XML

  - Be wary of poison message

  - Configure MDB pool size
* EJB Proxy							       :EJB3:
  The container makes beans "special" by acting as a proxy between the client
  and the actual bean instance. This enables the container to provide EJB
  services to the client on behalf of the bean instance. 

  For each bean instance, the container automatically generates a proxy called
  an /EJB object/. The EJB object has access to all the functionality of the
  container, including the JNDI registry, security, transaction management,
  thread pools, session management, and pretty much anything else that is
  necessary to provide EJB service.

* Setter Injection						      :@EJB3:
  Other than field injection, you may also use setter injection that provide
  injeciton on a setter method. In this way, Injection will happen to the
  paramter of setter method. There are two benifits according to "EJB 3 in
  Action":
  
  1. It is easier to unit-test by invoking the public setter method from a
     testing framework.

  2. It is easier to put initialization code in the setter method.

* Multiple interceptors, multi-level interceptors		      :@EJB3:
  If you specified default, class-, and method-level interceptor, then they will
  be executed in the order:

  Default Interceptor -> Class Interceptor -> Method Interceptor

  If more than one interceptor is applied at any given level, then they are
  executed in the order which they are specified.

  The only way to alter this execution order is to use the /interceptor-order/
  element in the deployment descriptor; there are no annotation for changing
  interceptor order. 

* Disable interceptor						      :@EJB3:
  - /@javax.interceptor.ExcludeDefaultInterceptor/ annotation ::
    disable default interceptor.

  - /@javax.interceptor.ExcludeClassInterceptor/ annotation ::
    disable class interceptor.

* Interceptor and Exceptions
  If a business method interceptor throws an exception before invoking the
  proceed method, the processing of other interceptors in the invocation chain
  and the target business method will be terminated.

* Lifecycle callback methods in the interceptor class
  Lifecycle callback defined in an interceptor class are known as /lifecycle
  callback interceptors/ or /lifecycle callback listeners/. When the target bean
  transition lifecycles, annotated methods in the interceptor class are
  triggered.

  Note that a bean can have the same lifecycle callbacks both in the bean itself
  as well as in one or more interceptors. That is the whole point of calling the
  /InvocationContext.proceed/ method in lifecycle interceptor methods as in the
  resource logger code.

* Timers							      :@EJB3:
  EJB 3 timer service allows you to specify a method that is automatically
  invoked after a specified interval of time. 

  We can only use timers in stateless session beans and MDBs because their
  asynchronous, stateless nature. However, unlike stateless session bean and
  MDBs, Timers are persistence and can survive a container crash or
  restart. Timers are also *transactional*, that is, a transaction failure in a
  timeout method rolls back the action taken by the timer.

* Transactions							      :@EJB3:
  In the most basic terms, a /transaction/ is a grouping of tasks that must be
  processed as an inseparable unit. 

  In addiion to the *all-or-nothing* value proposition, transaction must
  guarentee a degree of reliability and robustness. 

  A successful transaction is committed, meaning its result are made permanent,
  whereas a failed transaction is rolled back, as if it nerver happened.


* /setRollbackOnly/ and /getRollbackOnly/			      :@EJB3:
  The /setRollbackOnly/ and /getRollbackOnly/ methods can only be invoked in an
  EJB using CMT with these transaction attributes: REQUIRED, REQUIRED_NEW, or
  MANDATORY. Because they can only be invoked in a situation it is guaranteed
  that there is CMT. Otherwise, the contianer will throw an
  /IllegalStateException/.

* Transaction and Exception					      :@EJB3:
  By default, all checked exception except for /java.rmi.RemoteException/ are
  assumed to be application exceptions that will cause rollback. On the other
  hand, all exceptions that inherit from either java.rmi.RemoteExceptions or
  java.lang.RuntimeException are assumed to be system exception. In EJB, it is
  not assumed that system exceptions are expected by the client. When
  encountered, such exceptions are not passed to the client as is but are
  wrapped in a javax.ejb.EJBException instead.

* UserTrasaction Interface
  The /UserTrasaction/ interface encapsulates the basic functionality provided
  by a Java EE transaction manager. 

* Transaction apply to transactional resources			      :@EJB3:
  Transactions apply to transactional resources, the Java EE specification
  recognizaing three types of transactional resources: JDBC databases, JMS
  destinations, and "other transactional services accessed through JCA"

  state-variable and static variables are not transactional resources. File
  system is neither not transactional resource, unless you're writting to the
  file system through JCA connector.

* Authentication and Authorization				      :@EJB3:
  Securing an application involves two primary functions: authentication and
  authorization. 

** Authentication
   Authentication is the process of verifying user identify. By authentication
   yourself, you prove that you are who you say you are.

** Authorization
   Authorization is the process of determining whether a user has access to a
   particular resource or task, and it comes into play once a user is
   authenticated. 

* Groups and Roles						      :@EJB3:
  It's impossible for you to code for the specific group names a customer's
  system administrator will choose. Neither should you care about groups. What
  you do care about is what role a particular in a group plays for your
  application.

  [So roles are associated with groups here]

* EJB 3 and Java EE security
  Java EE security is largely based on the Java Authentication and Authorization
  Service (JAAS) API. JAAS essentially separates the authentication system from
  the Java EE application by using well-defined, pluggable API.
  
  The Java EE application need only know how to talk to the JAAS API. The JAAS
  API, in contrast, knows how to talk to underlying authentication systems like
  Lightweight Directory Access Protocol(LDAP), such as Microsoft Active
  Directory or Oracle Internet Directory(OID) using a vendor plug-in. As a
  result, you can easily swap betwen anthetication systems simply by swapping
  JAAS plug-ins without changing any code.

* Declare autheticated roles
  There are many ways to declare autheticated roles:
  1. By using /@DeclareRoles/ annotation at either the method or the class level
     and consists of an array of role names.
  2. Sepcify roles for the entire enterprise application or EJB module through
     deployment descriptors.
  3. If we never declare roles, the container will automatically build a list of
     roles by insepcting the /@RoleAllowed/ annotation. 

     When the application is deployed, the local system admnistrator must map
     each role to groups defined in the runtime security environment.

* Persistence Archive						      :@EJB3:
  Many developer think a separate persistence module is a bad idea because
  entities are supported both outside and inside the container. Considering that
  persistence is inherently a part of any enterprise application, it makes sense
  to support packaging entities with most module types, instead of introducing a
  new module type specialized for packaging entites.
* J2EE archives
  | Type    | Descriptor             | Description                             |
  |---------+------------------------+-----------------------------------------|
  | CAR     | application-client.xml | Thick java client for EJBs              |
  |         |                        |                                         |
  | EAR     | application.xml        | Toplevel enterprise application archive |
  |         |                        |                                         |
  | EJB-JAR | ejb-jar.xml            | EJB archive, contain all kinds of beans |
  |         |                        | may contain an persistent.xml file if   |
  |         |                        | There is any persistence entity         |
  |         |                        |                                         |
  | RAR     | ra.xml                 | Resource adapter archive                |
  |         |                        |                                         |
  | WAR     | web.xml                | Web application archive                 |

* Java EE 5 Automatic Deployment
  Java EE 5 made the deployment descriptor optional, even in the EAR. This is a
  departure from previous version of Java EE, where it was mandatory. The Java
  EE 5.0-compliant application servers deploy by performing automatic detection
  based on a standard naming convention or reding the content of archives; 

* Java EE Class Loader						      :@EJB3:
  There is no Java EE specification provides a standard for class loading, and
  each application server implements class loader in whatever way seems best to
  the vendor. 

  Basically, application server uses a EAR class loader to load all JARs in the
  /lib/ directory that shared between each modules. EJB class loader loads EJBs,
  and it is a child class of EAR class loader, so all classes loaded by EJB
  class loader is visible to EJB classes. The classes loaded by EJB class loader
  are typically visible to the web module in most containers because the WAR
  class loader is a child of EJB class loader.

* Helper Classes Visibility					      :@EJB3:
  - To make helper classes be visible to all modules in the EAR module, just
    package thme in the lib directory which will be automatically visible to all
    modules.

  - If you want to limit the visibility to only a specific EJB-JAR or WAR
    module, you can create an entry in the /Manifest.mf/ file of the module that
    contains a /class-path/ attribute to the JAR file.
  
* Exposing the persistence module				      :@EJB3:
  With EJB3, entities can be used inside either the EJB or web container, or in
  a Java SE application. Thus, entities may be packaged in a standard Java EE
  module such as an EJB-JAR, WAR, or JAR file in the root of the EAR module or
  as a library module in an EAR. When using entities in your applications, you
  have to package entity classes into a Java EE module such as an EJB-JAR or WAR
  of simple JAR files, with a simple deployment descriptor named
  /persistence.xml/.

  If you are using entities within an EJB module, then the EJB classes and
  entities need to be packaged together in the same EJB module. Therefore, the
  EJB-JAR module will contain a persistence.xml file to designate that the
  module contains one or more persistence units. 

* Design Pattern and J2EE					      :@EBJ3:
  Design patterns are generally accepted solutions that typically work for
  common problems. They help avoid "Rediscovering the Wheel Syndrome," and offer
  advice for when and how they should be used. Sun's Java Blueprints Program
  provides a catalog of core design patterns for building Java EE
  applications.


* Domain Model							       :@JPA:
  A /domain model/ is a conceptal image of the problem your system is trying to
  solve. Literally , it is made up of the objects in the "system universe" and
  the relationships or associations between them.

  The critial thing to remmember is that the domain model describes the objects
  and how the objects might relate to each other, but not how a system acts on
  the objects.

* Domain Model Actors
  Domain modeling theory identifies four domain model "actors": 
  - objects
  - relationship 
  - the multiplicity of relationships
  - the optionality of relationships

* Rich vs. Anemic Domain Models					       :@JPA:
  - Anemic domain objects contain only attributes but not behaviors.
  - Rich domain objects contain both attributes and behaviors

* Inheritance and Persistence					       :@JPA:
  If parent class is annotated with @Entity, then all the inherited fields will
  be persistented in an Entity child class. But if parent class is not an
  entity, then the value of the inherited properties will be discarded when
  entity child class is persisted. 

* Field Based Access vs. Property Based Access			       :@JPA:
  + field based access ::
    - defining O/R mapping using fields or instance variable of entity.
    - put annotation on field 

  + property based access ::
    - defining O/R mapping using getter/setter method
    - put annotation on getter method

  Annotation used with a setter are ignored by the persistence provider for
  property-based access

  One caveat in choosing between field and property based persistence is that
  both are one-way streets; you can't mix and match access types in the same
  entity or in any entity inthe POJO hierarchy. 


* Transient Field						       :@JPA:
  You can stop an entity property from being persisted by marking the field or
  getter with the /@Transient/ annotation. 

  Note that defining a field with the transient modifier as we've done with
  generatedName has the same effect as the /@Transient/ annotation.

* Entity Identity
  Every entity of the domain model must be uniquely identifiable. This
  requirement is due partly to the fact that at some point entities must be
  persisted into a uniquely identifiable row in a database table.

** The @Id annotation
   /javax.persistence.Id/ annotation is the simplest way of telling the
   persistence provider where the entity identity is stored. The /@Id/
   annotation marks a field or property as identity for an entity. 

   Use /@Id/ can only identify one field or property as the identity, if you
   want to sepcify multiple fields or properties as identity, then you probably
   have to use /@IdClass/ or /@EmbeddedId/

** The /@IdClass/ annotation
   In effect, the @IdClass annotation enables you to use more than one /@Id/
   annotation in a sensible way. 

   By using /@IdClass/, you may specify multiple /@Id/ field or properties and
   annotate the class with /@IdClass/ to specify how to compare multiple
   identity fields using an external /@IdClass/.

   

** The /@EmbeddedId/
   Using the /@EmbeddedId/ annotation is like moving the /IdClass/ right into
   your entity and using the identity fields nested inside it to store entity
   data. You are not allowed to use /Id/ or /IdClass/ in conjunction with
   /EmbeddedId/.

* The /@Embeddable/ annotation
  The /@Embeedable/ annotation is used to designate persistent object that need
  not have an identify of their own. This is because Embeddable objects are
  identified by the entity objects they are nested inside and never persistend
  or accessed on their own.

  EJB 3 API does not support nested embedded objects. 

* Entity Relationships
  | type of relationship | annotation  |
  |----------------------+-------------|
  | one-to-one           | @OneToOne   |
  | one-to-many          | @OneToMany  |
  | many-to-one          | @ManyToOne  |
  | many-to-many         | @ManyToMany |

** @OneToOne
   The /@OneToOne/ annotation is used to mark uni- and bidirectional one-to-one
   relationships. 
   
   the /mappedBy/ specification tells the container that the "owning" side of
   the relationship. The concept of a /relationship owner/ doesn't originate
   from domain modeling. It exists as a convenience to define the database
   mapping for a relationship only once instead of repeating the same mapping
   for both direction of a relationship.

* Annotation Concept and Terminalogy				:@Annotation:
  - annotation ::
    An annotation associates arbitrary information or metadata with a java
    program element. Annotation uses new syntax introduced in Java 5.0 and
    behave like modification such as /public/ or /final/. 

  - annotation type ::
    The name of an annotation as well as the names, types, and default values of
    its members are defined by the /annotation type/. An annotation type is
    essentially a java interface with some restriction on its members and some
    new syntax used in its declaration. 

  - annotation member ::
    The members of an annotation are declared in an annotation type as
    no-argument methods. The method name and return type define the name and
    type of the member. A special default syntax allows the declaration of a
    default value for any annotation member. 

    This is really a very bad design of semantic.

  - meta-annotation ::
    A meta-annotatoin is an annotation applied to the declaration of an
    annotation type.

  - retention ::
    The retention of an annotation specifies how long the information contained
    in the annotation is retained. 

* Defining Annotation Types
  An annotatoin type is a interface, but it is not a normal one. An annotation
  type differs from a normal interface in the following ways:
  - defined with @interface. An @interface declaration 

  - the method of annotation should be defined with no arguments and may not
    throw exceptions.

  - the return value of annotation methods may be a primitive type, a String, a
    Class, an enumeration type, another annotation type, or a single-dimensional
    arry of one of those types

  - any method of an annotation type may be followed by the keyword /default/
    and a value compatible with the return value of the method.This strange new
    syntax specifies the default value of the annotation member that corresponds
    to the method.

  - annotation types and their methods may not have type parameter. The only
    valid use of generics in annotation type is for methods whose return type is
    /Class/. These methods may use a bounded wildcard to specify a constraint on
    the returned class.

  - annotations may include constant definitions and static member types such as
    enumerated type definitions. 

  - Annotation types may also be implemented or extended just as normal
    interfaces are. But the classes or interfaces that result from doing this
    are not themselves annotation types. 

* Meta Annotations						:@Annotation:
  - Target ::
    The /Target/ meta-annotation type specifies the "targets" for an annotation
    tpe. That is, it specifies which program elements may have annotations of
    that type. 

    The /Target/ meta-annotation type has a single member named /value/. The
    type of this member is /java.lang.annotation.ElementType[].ElementType/ is
    an enumerated type whose enumerated values represent program elements that
    can be annotated, those values could be:

    1. ANNOTATION_TYPE
    2. CONSTRUCTOR
    3. FIELD
    4. LOCAL_VARIABLE
    5. METHOD
    6. PACKGE
    7. PARAMETER
    8. TYPE

  - Retension ::
    Specify the retension of the annotation, the /Retension/ meta-annotation
    type has be single member named /value/ whose type is /RetentionPolicy/, the
    value could be :
    
    1. CLASS
    2. RUNTIME
    3. SOURCE

  - Documented ::
    /Documented/ is a meta-annotation type used to specify that annotations of
    some other type should be considered part of the public API of the annotated
    program elment and should therefore be documented by tools like
    javadoc. /Documented/ is a marker annotation: it has no members. 

  - Inherited ::
    Indicate that the annotation is a inherited one, that is, if the annotation
    is used to a class, then the annotation applies to subclasses of that class
    as well.

    Note that /@Inherited/ annotation types are inherited only by subclasses of
    an annotation class. Classes do not inherit annotations from interfaces they
    implement, and methods do not inherit annotation from methods they
    override. 

* Object-relational mapping
  In effect, ORM speicfies how sets of Java objects, including references
  between them, are mapped to rows and columns in database tables. 

  - One-to-one mapping
    Storing data into two tables and use foreign key reference does not make
    complete sense in relational world. It would be better to annotate class to
    be /embedded/ and let retional database to merge two tables into one.

  - One-to-many mapping
    The relational primary-key/foreign-key mechanism is ideally suited for a
    parent-child one-to-many relationship between tables. 

  - Many-to-many mapping
    The only way to implement many-to-many relationships is by breaking them
    down into two one-to-many relationsihps. 

    An /association/ or /intersection/ table will be involed which contains only
    two columns to mapping the primary keys for the two sides of many-to-many
    relationship. 

* Enum in Java 5.0						       :Language:
  Enum is a new type supported in Java 5.0. Basically, it performs as the the
  ordinary enumeration types in other languages to define certain number of
  values for a certain type. Java 5.0 also add supporting for the enum type in
  /swith/ statement. 

  But enum is more complex in java, it could actually be considered as a class,
  and each value defined in this enum could be considered as singleton instance
  of classes inherited from the enum class, or you may consider it as singlton
  class in Scala language. So you could define class body for the enum type and
  also for all values. As following example:
#+BEGIN_SRC java
  enum ArithmeticOperator {
      ADD {
          double apply(double x, double y) {
              return x + y;
          }
          
      }, 
      SUBTRACT {
         double apply(double x, double y) {
              return x - y;
          }        
      };
  
      double apply(double x, double y) {
          throw new AssesionError(this);
      }
  }
#+END_SRC

* Mapping CLOBs and BLOBs					       :@JPA:
  Whether a field or property designated /@Lob/ is a CLOB or a BLOB is
  determined by its type. If the data is of type /char[]/ or /String/, the
  persistence provider maps the data to a /CLOB/ column. Otherwise, the column
  is mapped as a /BLOB/. 

* Mapping temporal types					       :@JPA:
  Most databases support a few different temporal data types with different
  granularity levels corresponding to DATE(storing day, month, and year),
  TIME(storing just time and not day, month, or year) and TIMESTAMP(storing
  time, day, month and year). The /@Temporal annotation specifies which of these
  data types we want to map a /java.util.Date/ or /java.util.Calendar/
  persistent data type to.

* Mapping an entity to multiple tables				       :@JPA:
  /@SecondaryTable/ is used to map an entity to multple tables. 

  /pkJoinColumns/ element in /@SecondaryTable/ annotation is used to specify the
  relationship between those tables. 

  We may use the /@SecondaryTables/ annotation more than once for the same entity.
  
* Generating Primary Keys					       :@JPA:
  Three strategies are supported via the /@GeneratedValue/ annotation to
  support primary key generation

  - Identity columns ::
    Some databases support identify column which is a column to have unique
    value, the value of this column may be generated by the database or be
    specified by the user when rows are created. 

    /GenerationType.IDENTITY/ value could be used for the /startegy/ key to
    specify the generation strategy to be identity:
#+BEGIN_SRC java
    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    @Column(name="USER_ID")
    protected Long userId;    
#+END_SRC
    
  - Database Sequence ::
    Database sequence is supported some databases. To use a database sequence to
    generate primary key, first you need to create the sequence in the
    database. Then you could specify this sequence with /@SequenceGenerator/
    annotation. And finally you may use the sequence in the /@GeneratedValue/
    annotation as following:
#+BEGIN_SRC java
    // specify the sequence
    @SequenceGenerator(name="USER_SEQUENCE_GENERATOR",
       sequenceName="USER_SEQUENCE",
       initialValue=1, allocationSize=10)
    
    // use the sequence as the primary generator
    @Id
    @GeneratedValue(strategy=GenerationType.SEQUENCE,
                    generator="USER_SEQUNECE_GENERATOR")
    @Column(name="USER_ID")
    protected Long userId;
#+END_SRC
    
  - Sequence Table ::
    As database sequence, sequence table is also a method for sequence
    generator that supported by database such as oracle. To use a sequence table
    as primary key generator, you also have to create the sequence table in the
    database firstly. 

#+BEGIN_SRC java
    @TableGenerator (name="USER_TABLE_GENERATOR",
      table="SEQUENCE_GENERATOR_TABLE",
      pkColumnName="SEQUENCE_NAME",
      valueColumnName="SEQUENCE_VALUE",
      pkColumnValue="USER_SEQUENCE")

   @Id
   @GeneratedValue(strategy=GenerationType.TABLE,
     generator="USER_TABLE_GENERATOR")
   @Column(name="USER_ID")
   protected Long userId;
#+END_SRC    

  - Default primary key generation strategy ::
    You may also specify the strategy to be /AUTO/ and let the persistence
    provider decide the best strategy for the underlying database. 
#+BEGIN_SRC java
    @Id
    @GeneratedValue(strategy=GenerationType.AUTO)
    @Column(name="USER_ID")
    protected Long userId;

#+END_SRC
    
* Mapping Entity Relationships					       :@JPA:
** Mapping one-to-one relationship
   one-to-one relationship are mapped using primary/foreign key associations. 

   - Using @JoinColumn ::
     If the underlying table for the referencing entity is the one containing
     the foreign  key to which the referenced "child" entity is mapped, you can
     map the relationship using the /@JoinColumn/ annotation.
     
     In /@JoinColumn/ annotation, the /referenceColumnName/ element specifies
     the name of the primary key or a unique key the foreign key refers to. The
     default value of /referenceColumnName/ is the column containing the
     identity of the referenced entity.

     If we have a bidrectional one-to-one relationship, then the entity in the
     inverse side of the relationship will contain the mappedBy
     element. /mappedBy/ element identifies the name of the association field in
     the owning side of the relationship. 

 - Using /@PrimaryKeyJoinColumn/ ::
   In the more likely case that the foreign key reference exists in the table to
   which the referenced entity is mapped, the /@PrimaryKeyJoinColumn/ would be
   used instead. 

   In this case, we will have a foreign key in the referenced table to refer to
   the primary key of the master table. We may use /@PrimaryKeyJoinColumn/ on
   master table's primary key field and set /referencedColumnName/ to be the
   foriegn key field of referenced table.

** One-to-many and many-to-one
   In the one-to-many and many-to-one relationship, we have multiple reference
   in the object on the "One" side to "Many" side and also one reference in the
   "Many" side object to "One" side. 

   So we may use the /mappedBy/ in the one-to-may relationship to emphasis the
   master of the relationship. And we also use /@JoinColumn/ in the many-to-one
   relationship to specify how foreign key and primary key are mapped. 

   If you do not specify /mappedBy/ element, then persistence provider will
   treate it as a undirectional relationship, but this would not be possible if
   the one-to-many relationship reference were unidirectional since there would
   be no owner of the relationship to refer to.

   JPA does not support unidirectional one-to-many relationships using a foreign
   key on the target table. Unidirectional one-to-many relationship will need to
   involve in maintaining another table.

** Many-to-many
   Join table allows you to indirectly match up primary keys from either side of
   the relationshion by storing arbitrary pairs of foreign keys in a row.
   
   A /@JoinTable/ annotation may contain two /@JoinColumns/ to specify how
   primary keys in object tables could be mapped to foreign keys in join
   table. And you may use a /mappedBy/ element to reduce redundant mapping.

   If there is no /mappedBy/ element, then it will become a unidirectional
   many-to-many mapping.

* Mapping Inheritence						       :@JPA:
  There are several ways to map inheritance:
  1. Single table
  2. joined tables
  3. table per class

** Single table strategy
   In single-table strategy, all classes in the inheritence hierarchy are mapped
   to a single table. This means that the single table will contain a superset
   of all data stored  in the class hierarchy. Different objects in the OO
   hierarchy are identified using a special column called a /discriminator/
   column. 
   
** Joined-tables strategy
   Joined-tables inheritance strategy uses one-to-one relationships to modle OO
   inehritance. The master table stores only data that is common to all child
   classes, different tables are created for each descedent class type, and
   foreign -> primary key mapping is created between classes to map a specific
   descedent object to its own common data. The discriminator column is also
   used to easily identify the object type.

** Table-per-class strategy
   
* Methods to manipulate entities				       :@JPA:
  - persist ::
    persist attach a detached entity into EntityManaer's context. 
    
  - merge ::
    merge update the database with the data held in the entity and attach the
    entity to EntityManager's context.

  - refresh ::
    refresh resets the entity's state with data from the database.

* Detach entity							       :@JPA:
  The usual way entities become detached is a little subtler. Essentially, an
  attached entity becomes detached as soon as it goes out of the /EntityManager/
  context's scope. 

  Entity instances also become detached through cloning or serialization. This
  is because the EntityManager quite literally keeps track of entities through
  Java object references.
  
  
* Persistence context						       :@JPA:
  Although we perform persistence operations by invoking methods on the
  /EntityManager/, the /EntityManager/ itself does not directly keep track of
  the lifecycle of an individual entity. /EntityManager/ delegates the task of
  managing entity state to the currently available persistence context.

  A persistence context is a self-contained collection of entities managed by an
  /EntityManager/ during a given persistence scope. 

  There are two different of persistence scopes: transaction and extended.

* Transaction-scoped EntityManager				       :@JPA:
  An EntityManager associated with a transaction-scoped persistence context is
  known as a transaction-scoped EntityManager. If a persistence context is under
  transaction scope, entities attached during a transaction are automatically
  detached when the transaction ends. 

  Once the persistence context detects that a transaction has either been rolled
  back or committed, it will detach all managed entities after making suer that
  all data changes until that point are synchronized with the database.

* Extended EntityManager					       :@JPA:
  The life span of the extended /EntityManager/ lasts across multiple
  transactions. An extended EntityManager can only be used with stateful session
  beans and lasts as long as the bean instance is alive. 

  You are not allowed use extended persistence scope for stateless session beans
  or MDBs. 
* Creating EntityManager instance				       :@JPA:
  All EntityManager instances injected using the /@PersistenceContext/
  annotaiton are container managed. This means that the container takes care of
  the mundane task of looking up, opening, and closing the EntityManager behind
  the scene. In addition, unless otherwise specified, injected /EntityManager/
  have *transaction* scope.

  Unlike container-managed /EntityManager/, application-managed EntityManagers
  do not automatically participate inan enclosing transaction. Instead, they
  must be asked to join an enclosing JTA transaction by calling the
  /joinTransaction/ method. 

* Cascading persist operations					       :@JPA:
  Perhaps surprisingly, it is not the default behavior for JPA to persist
  related entities. 

* Retriving Entities by Primary Key				      :@JPAA:
  If an entity instance matching the specified key does not exist in the
  database, the find method will not throw any exceptions. Instead, the
  Entity-Manager will return null or an empty entity and your application must
  handle this situation.

  It is not strictly necessary to call the find method in a transactional
  context. However, the retrieved entity is detached unless a transaction
  context is available, so it is generally advisable to call the find method
  inside a transaction.
* Deleting Entities						       :@JPA:
  /remove/ method of /EntityManage/ can only delete *currently attached*
  entities. If a detached entity is passed to the /remove/ method, it throws an
  IllegalArgumentException. So we an unattached object is passed in, you may
  need to call /merge/ firstly to attach the object into persistence context.
  
* Controlling updates with flush				       :@JPA:
  By default, the database flush mode is set to AUTO. This means that the
  /EntityManager/ performs a flush operation automatically as needed. In
  general, this occurs at the end of transaction for transaction-scoped
  EntityManager and when the persistence context is closed for
  application-managed or extended-scope EntityManager. 

  You can set the flush mode of /EntityManager/ with
  /EntityManager::setFlushMode/. then it is your responsibility to synchronize
  entity state with the database before executing a query. 

  In reality, resetting flush mode is often overkill. This is because you can
  explicitly flush the EntityManager when you need to with /flush/ method in
  /EntityManager/ class.

* Refreshing Entities						       :@JPA:
  The /refresh/ operation repopulates entity data from the database. In other
  words, given an entity instance, the persistence provider matches the entity
  with a record in the database and resets the entity with retrieved data from
  the database.

* Default Listener Classes					       :@JPA:
  For crosscutting concerns like logging or auditing, it is incovenient to have
  to specify listeners for individual entities. So JPA enables you to specify
  default entity listeners that receive callbacks from all entities in a
  persistence unit. 

* Listener class execution order				       :@JPA:
  If an entity has default listeners, entity class-specific listeners, and
  inherited superclass listeners, then the executio order of those listeners is:

  Default Entity Listener -> Listeners on Superclass -> Listeners on Subclass


* @JoinColumn and @PrimaryKey					       :@JPA:
  In One-to-One relationship, there are two places that foreign key may
  exist. 

  - Using @JoinColumn 

    If the foreign key is in the table to which the reference class is
    mapped. Means the field of the foreign key is in the master class. Then
    @JoinColumn should be used.

    For example, if we have a User class which defines user information and also
    a BillingInfo class that contains billing information for a specific
    user. Then we may have a field in User class reference to a BillingInfo
    instance. We could be /@JoinColumn/ here to map this relationship:
#+BEGIN_SRC text
  @Entity
  @Table(name="USERS")
  public class User {
     @Id
     @Column(name="USER_ID")
     protected String userId;
  
     @OneToOne
     @JoinColumn(name="USER_BILLING_ID",
       referencedColumnName="BILLING_ID", updatable=false)
     protected BillingInfo billingInfo;        
  }
  
  @Entity
  @Table(name="BILLING_INFO")
  public class BillingInfo {
      @Id
      @Column(name="BILLING_ID")
      protected Long billingId;
  }
#+END_SRC    
  
  Here we specify that field billingInfo is a foreign key reference to the
  "BILLING_ID" in the BillingInfo class.

  - Using @PrimaryKeyJoinColumn
    If the foreign key is in the table that referenced class is mapped. Means
    the field of this foreign key is in the referenced class. Then we should be
    /@PrimaryKeyJoinColumn/. Also table class User and class BillingInfo as
    example, we will have:
#+BEGIN_SRC text
    @Entity
    @Table(name="USERS")
    public class User{
        @Id
	@Column(name="USER_ID")
	protected Long userId;

	@OneToOne
	@PrimaryKeyJoinColumn(name="USER_ID"
	  referencedColumnName("BILLING_INFO_ID")
	protected BillingInfo billingInfo;
    }

    @Entity
    @Table(name="BILLING_INFO")
    public class BillingInfo {
        @Id
	@Column(name="BILLING_UESR_ID")
	protected Long UserId;
    }
#+END_SRC

    Here the /referencedColumnName/ of /@PrimaryKeyJoinColumn/ annotation
    specify the name of the foreign key. If th enames of both the primary key
    and foreign key columns are the same, you may omit the
    /referencedColumnName/.

    /@PrimaryKeyJoinColumn/ also could be used to map inheritance
    relationship. In this cicumstance, we have foreign key in the child table
    refer to primary key in parent table to fetch common data stored there. We
    need to specify /@PrimaryKeyJoinColumn/ in child table mapping to indicate
    the name of primary key.

* Unidirectionl One-to-Many Relationship			       :@JPA:
  Unidirectional one-to-many is actually not recommended in JPA. If the
  relationship is bidirectional one-to-many, then you may very easilly map
  between two objects with /@OneToMany/ in the owner object and /@ManyToOne/ in
  the owned object plus one /@JoinColumn/ to specify the foreign key. Also take
  class /User/ and class /BillingInfo/ as example, assume one user may have a
  list of billing infos, then a bidirectional relationship would be:

#+BEGIN_SRC text
  @Entity
  @Table(name="USERS")
  public class User {
      @Id
      @Column(name="USER_ID")
      protected Long userId;

      // specify mappedBy to indicate the relationship is described by the 
      // user field in BillingInfo class.
      @OneToMany(mappedBy="user")
      protected List<BillingInfo> billingInfoList;
  }

  @Entity
  @Table(name="BILLING_INFO")
  public class BillingInfo {
      // @JoinColumn.name specify the name of column
      // @JoinColumn.referencedColumnName specify the column this foreign key
      //  refer to, which is the USER_ID column in USERS table.
      @ManyToOne
      @JoinColumn(name="BILLING_USER_ID"
          referencedColumnName="USER_ID")
      protected User user;
  }
#+END_SRC  

  But for a unidirectional relationship, although almost all persistence
  provider already support a simple /@JoinColumn/ description as following:

#+BEGIN_SRC java 
  @Entity
  @Table(name="USERS")
  public class User {
      @Id
      @Column(name="USER_ID")
      protected Long userId;

      // not standard
      @OneToMany(mappedBy="user")
      @JoinColumn(name=BILLING_USER_ID")
      protected List<BillingInfo> billingInfoList;
  }

  @Entity
  @Table(name="BILLING_INFO")
  public class BillingInfo {
      // no bidirectional
  }
#+END_SRC
  This would work in most presistence provider, but it is not standard in JPA,
  so not recommended.

  if you really want to use a bidirectional One-to-Many relationship, then you
  would probably consider /@JoinTable/ as a better solution. /@JoinTable/ in
  unidirectional /@OneToMany/ is the almost the same as /@JoinTable/ in
  /@ManyToMany/ relationship, just miss the part in owned object:
#+BEGIN_SRC java
  @Entity
  @Table(name="USERS")
  public class User {
      @Id
      @Column(name="USER_ID")
      protected Long userId;

      // not standard
      @OneToMany(mappedBy="user")
      @JoinTable(name="USER_BILLING_INFO",
          joinColumns = 
	    @JoinColumn(name="UB_USER_ID",	    
                        referencedColumnName="USER_ID"),
          inverseJoinColumns=
            @JoinColumn(name="UB_BILLING_INFO_ID",
                        referencedColumnName="BILLING_INFO_ID")
      )
      protected List<BillingInfo> billingInfoList;
  }

  @Entity
  @Table(name="BILLING_INFO")
  public class BillingInfo {
      // no bidirectional
  }
#END_SRC

* Using Join Columns						       :@JPA:
  In the database, a relationship mapping means that one table has a reference
  to another table. The database term for a column that refers to a key (usually
  the primary key) in another table is a /foreign key/ column. In the Java
  Persistence API we call them /join columns/, and the /@JoinColumn/ annotation
  is the primary annotation used to configure these types of columns.

  In almost every relationship, independent of source and target sides, one of
  the two sides is going to have the join column in its table. That side is
  called the owning side or the owner of the relationship. The side that does
  not have the join column is called the non-owning or inverse side.
  
  Ownership is important for mapping because the physical annotations that
  define the mapping to the columns in the database are always defined on the
  owning side of the relationship. If they are not there, then the values are
  defaulted from the perspective of the attribute on the owning side.

* Unidirectional Many-to-One Relationship			       :@JPA:
  Defaultly, Many-to-One relationship requires only one /@ManyToOne/
  annotation on the owning side class. As a example from the book "Pro EJB3,
  Java Persistence API", we have a class /Employee/ with a reference to class
  /Department/ that is a Many-to-One relationship.

#+BEGIN_SRC text
  @Entity
  @Table(name="EMPLOYEE")  
  public class Employee {
  // ...
  @ManyToOne
  private Department department;
  }
#+END_SRC  
  
  Actually, that is all we need to do. When there is no /@JoinColumn/, then
  persistence provider will use a defaultly generated column name.

  /@JoinColumn/ annotation here could be used to specify values for the foreign
  key relationship.
#+BEGIN_SRC text
  @Entity
  @Table(name="EMPLOYEE")  
  public class Employee {
  // ...
  @ManyToOne
  @JoinColumn(name="DEPT_ID")
  private Department department;
  }
#+END_SRC  
  Here, we specify the name of the foreign key to be DEPT_ID.

* Unidirectional One-to-One relationship
  Just as Many-to-One relationship, One-to-One relationship also use a foreign
  key(join column) in the database to specify the relationship, so you may use a
  /@JoinColumn/ annotation to override default values for this join column.
#+BEGIN_SRC text
  @Entity
  @Table(name="EMPLOYEE")  
  public class Employee {
  // ...
  @OneToOne
  @JoinColumn(name="DEPT_ID")
  private Department department;
  }
#+END_SRC  

* Bidrectional One-to-One Relationship
  In a bidirectional one-to-one relationship both of the mappings are one-to-one
  mappings, and either side may be the owner, so the join column may end up
  being on one side or the other.

  Here is the rules to do the mapping:
  - The /@JoinColumn/ annotation goes on the mapping of the entity that is
    managed to the table containing the join column, or the owner of the
    relationship. This may be on either side of the association

  - The /mappedBy/ element should be specified in the /@OneToOne/ annotation in
    the entity that does not define a join column, or the inverse side of the
    relationship. 

* One-to-One Primary Key Mapping
  If the database table does not have an additional foreign key column in either
  table and the primary key in one of the table is also the foreign key refering
  to the other table. Then we should use /@PrimaryKeyJoinColumn/ to specify the
  One-to-One relationship. 

  We use the /@PrimaryKeyJoinColumn/ in the class which uses its primary key as
  foreign key to refer to the other class and use the /mappedBy/ attribute in
  the other class. 

* One-to-Many Relationship
  When a source entity has an arbitrary number of target entities stored in its
  collection, there is no scalable way to store those references in the database
  table that it maps to. It must, rather, let the tables of the entities in the
  collection have foreign keys back to the source entity table. This is why the
  one-to-many association is almost always bidirectional and never the owning
  side.

  There are two important points to remember when defining bidirectional
  one-to-many(or many-to-one) relationships:
  1. The many-to-one side is the owning side, so the join column is defined on
     that side.
  2. The one-to-many mapping is the inverse side, so the /@mappedBy/ element
     must be used. 

  Falling to specify the /mappedBy/ element in the /@OneToMany/ annotation will
  cause the provider to treat is as a unidirectional one-to-many relationship
  that is defined to use a join table. 

* Many-to-Many Relationship
  The only way to implement a many-to-many relationship is with a separate join
  table. 

  A join table consists simply of two foreign key or join columns to refer to
  each of the two entity types in the relationship. 
  


  
* Org Configuration
#+STARTUP: hidestars
#+TAGS: @EJB3 @Ant @AOP
#+TAGS: @DataType @Task
  
