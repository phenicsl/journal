* Resource Collections					     :@DataType:@Ant:
  A Resource Collection is an abstraction of an entity that groups together a
  number of resources. 

* Path-like Structures					     :@DataType:@Ant:
  /path/ and /classpath/ are used to represent the path concept with "path"
  separated by ":" and ";". 

  You may consider them as a container of pathes represent an /path/ that may be
  used in other places. There are several different ways to specify elements
  inside a /path/ container:
  1. Nested /pathelement/ element.
     There are two attribute for an /pathelement/ element: "path" attribute
     contains a string with pathes that separated by delimiter; "location"
     attribute that contains a specific location. Location could be a
     directory or file.
  2. Resource Collections that contains only file-type resources could be
     specified inside /path/. Common used resource collections includes
     /fileset/, /dirset/, /filelist/.
  3. Reference to another path-like structure via nested /<path>/ element.

* if/unless attribute for target				 :@Task:@Ant:
    A target has the ability to perform its execution if(or unless) a property
    has been set. For example:
#+BEGIN_SRC nxml
  <target name="java-env-check" unless="env.JAVA_HOME">
    <fail message="JAVA_HOME environment variables must be set."/>
  </target>
#+END_SRC
    This example will fail the building unless /JAVA_HOME/ environment variable
    has been set.

* @Stateless Annotation 					      :@EJB3:
  @Stateless annotation marks a stateless session bean. This means that the
  container automatically provides such services to the bean as :
  1. automatic concurrency control. (will create thread for each request to the
     session bean?)
  2. thread safety
  3. pooling
  4. transaction management. (How?)

* The whole point of building server-side application		      :@EJB3:
The *whole point* of building server-side application is that they can be shared
by a large number of remote clients at the same time. 

Because session beans are specifically meant to handle client requests, they
must support a high degree of concurrency safely and rebostly. 

* AOP								       :@AOP:
  AOP is the ability to isolate "crosscutting" concerns into their own modules and
  apply them across the application through configuration.

* The anatomy of session bean					      :@EJB3:
  Each session bean implementation has two distinct parts -- one or more bean
  interface and a bean implementation class. This is because clients cannot have
  access to the bean implementation class directly. Instead they must use
  session beans through a business interface. 

* Stateful and Stateless					      :@EJB3:
  As youâ€™ll soon see, however, this does not mean that stateless session beans
  cannot have instance variables. Even before we explore any code, common sense
  should tell us that session beans must cache some resources, like database
  connec- tions, for performance reasons. The critical distinction here is
  client expectations.  As long as the client does not need to depend on the
  fact that a session bean uses instance variables to maintain conversational
  state, there is no need to use a state- ful session bean.


* Life cycle callback methods					      :@EJB3:

  | Callback Annotation            | Type of EJB              | Used For ...                                  |
  |--------------------------------+--------------------------+-----------------------------------------------|
  | javax.annotation.Postconstruct | stateless, stateful, MDB | initialize resources                          |
  | javax.annotation.PreDestroy    | stateless, stateful, MDB | clean up resources                            |
  | javax.ejb.PrePassivate         | stateful                 | clean up resources that can not be serialized |
  | javax.ejb.PostActivate         | stateful                 | restore resources                             |

* Web Service Endpoint Interface				      :@EJB3:
  Web service endpoint interface is known as SEI. The ability to expose a
  stateless session bean as a SOAP-based web service is one of the most powerful
  features of EJB 3. All you need to do to make a bean SOAP accessible is mark a
  business interface with the @javax.jws.WebService annotation.

* Multiple Business Interface					      :@EJB3:
  Although it is tempting, but you *cannot* mark the same interface with more
  than one access type annotation, then interface could be either @Local,
  @Remote, or @WebService.

* Inject EJB to other tiers					      :@EJB3:
  It is legal to inject stateful session bean to another stateful session bean
  and the injected EJB will be automatically removed when the EJB contains it is
  removed.

  But you must not inject a stateful session bean into a stateless object, such
  as a stateless session bean or servlet that may be shared by multiple
  concurrent clients. 

* Passivating and Removing beans				      :@EJB3:
  The rules for passivation are generally implementation specific. Improper use
  of passivation policies(when passivition configuration is an option) may cause
  performance problems. You have to check the documentation for your EJB
  container and appropriately set passivation rules.

* The role of Messaging						       :@JMS:
  - Messaging is widely used to solve reliability and scalability issues.
  - Heterogeneous integration is one primary area where messaging plays a key role.
* The advantage of messaging					       :@JMS:
  - heterogeneous integration 
  - reduce system bottlenecks
  - increase scalability
  - increase end user productivity
  - architecture flexibility and agility

* Two kinds of messaging
  1. Point-to-Point
     The point-to-point messaging model allows JMS clients to send and receive
     messages both synchronously and asynchronously via virtual channels known
     as queues. The point-to-point messaging model has traditionally been a
     pull-based or polling-based model, where messages are requested from the
     queue instead of being pushed to the client automatically.
  2. Publish-and-Subscribe
     In the publish-and-subscribe model, messages are published to a virtual
     channel called a topic. Unlike the point-to-point model, message published
     to a topic using the publish-and-subscribe model can be received by
     multiple subscribers. The publish-and-subscribe messaging model is by and
     large a push-based model, where message are automatically broadcast to
     consumers without them having to request or poll the topic for new
     messages.

* JMS session
  In JMS, the Session object holds the transactional unit of work for messaging,
  not the Connection object. This is different from JDBC, where the Connection
  object holds the transactional unit of work. This means that when using JMS,
  an application will typically have only a single /Connection/ object but will
  have a pool of /Session/ objects.

* Service-Oriented Architecture					       :@SOA:
  Service-Oriented Architecture(SOA) describes an architecture style that
  defines business services that are abstracted from the corresponding
  enterprise service implementations. SOA has given rise to a new breed of
  middleware known as an Enterprise Service Bus, or ESB.

* RPC								       :@RPC:
  RPC attempts to mimic the behavior of a system that runs in one process. When
  a remote procedure is invoked, the caller is blocked until the procedure
  completes ans returns control to the caller. The synchronized nature of RPC
  tightly couples the client to the server.

  It is the synchronized, tightly coupled, interdependent nature of RPC systems
  that cause entire systems to fail as a result of failures in subsystems. 

* MDB best practice						      :@EJB3:
  - Choose your messaging models carefully. 
    You might find that PTP will solve your problem nine times out of ten. But
    for some broadcasting cases, pub-sub model would be appropriate.

  - Remember modularization
    Business logic should be decoupled and modularized away from
    messaging-specific concerns. An excellect practice is to put business logic
    in session beans and invoke them from the /onMessage/ method.

  - Make good use of message filter

  - Choose message types carefully
    to XML or not XML

  - Be wary of poison message

  - Configure MDB pool size
* EJB Proxy							       :EJB3:
  The container makes beans "special" by acting as a proxy between the client
  and the actual bean instance. This enables the container to provide EJB
  services to the client on behalf of the bean instance. 

  For each bean instance, the container automatically generates a proxy called
  an /EJB object/. The EJB object has access to all the functionality of the
  container, including the JNDI registry, security, transaction management,
  thread pools, session management, and pretty much anything else that is
  necessary to provide EJB service.

* Setter Injection						      :@EJB3:
  Other than field injection, you may also use setter injection that provide
  injeciton on a setter method. In this way, Injection will happen to the
  paramter of setter method. There are two benifits according to "EJB 3 in
  Action":
  
  1. It is easier to unit-test by invoking the public setter method from a
     testing framework.

  2. It is easier to put initialization code in the setter method.

* Multiple interceptors, multi-level interceptors		      :@EJB3:
  If you specified default, class-, and method-level interceptor, then they will
  be executed in the order:

  Default Interceptor -> Class Interceptor -> Method Interceptor

  If more than one interceptor is applied at any given level, then they are
  executed in the order which they are specified.

  The only way to alter this execution order is to use the /interceptor-order/
  element in the deployment descriptor; there are no annotation for changing
  interceptor order. 

* Disable interceptor						      :@EJB3:
  - /@javax.interceptor.ExcludeDefaultInterceptor/ annotation ::
    disable default interceptor.

  - /@javax.interceptor.ExcludeClassInterceptor/ annotation ::
    disable class interceptor.

* Interceptor and Exceptions
  If a business method interceptor throws an exception before invoking the
  proceed method, the processing of other interceptors in the invocation chain
  and the target business method will be terminated.

* Lifecycle callback methods in the interceptor class
  Lifecycle callback defined in an interceptor class are known as /lifecycle
  callback interceptors/ or /lifecycle callback listeners/. When the target bean
  transition lifecycles, annotated methods in the interceptor class are
  triggered.

  Note that a bean can have the same lifecycle callbacks both in the bean itself
  as well as in one or more interceptors. That is the whole point of calling the
  /InvocationContext.proceed/ method in lifecycle interceptor methods as in the
  resource logger code.

* Timers							      :@EJB3:
  EJB 3 timer service allows you to specify a method that is automatically
  invoked after a specified interval of time. 

  We can only use timers in stateless session beans and MDBs because their
  asynchronous, stateless nature. However, unlike stateless session bean and
  MDBs, Timers are persistence and can survive a container crash or
  restart. Timers are also *transactional*, that is, a transaction failure in a
  timeout method rolls back the action taken by the timer.

* Transactions							      :@EJB3:
  In the most basic terms, a /transaction/ is a grouping of tasks that must be
  processed as an inseparable unit. 

  In addiion to the *all-or-nothing* value proposition, transaction must
  guarentee a degree of reliability and robustness. 

  A successful transaction is committed, meaning its result are made permanent,
  whereas a failed transaction is rolled back, as if it nerver happened.


* /setRollbackOnly/ and /getRollbackOnly/			      :@EJB3:
  The /setRollbackOnly/ and /getRollbackOnly/ methods can only be invoked in an
  EJB using CMT with these transaction attributes: REQUIRED, REQUIRED_NEW, or
  MANDATORY. Because they can only be invoked in a situation it is guaranteed
  that there is CMT. Otherwise, the contianer will throw an
  /IllegalStateException/.

* Transaction and Exception					      :@EJB3:
  By default, all checked exception except for /java.rmi.RemoteException/ are
  assumed to be application exceptions that will cause rollback. On the other
  hand, all exceptions that inherit from either java.rmi.RemoteExceptions or
  java.lang.RuntimeException are assumed to be system exception. In EJB, it is
  not assumed that system exceptions are expected by the client. When
  encountered, such exceptions are not passed to the client as is but are
  wrapped in a javax.ejb.EJBException instead.

* UserTrasaction Interface
  The /UserTrasaction/ interface encapsulates the basic functionality provided
  by a Java EE transaction manager. 

* Transaction apply to transactional resources			      :@EJB3:
  Transactions apply to transactional resources, the Java EE specification
  recognizaing three types of transactional resources: JDBC databases, JMS
  destinations, and "other transactional services accessed through JCA"

  state-variable and static variables are not transactional resources. File
  system is neither not transactional resource, unless you're writting to the
  file system through JCA connector.

* Authentication and Authorization				      :@EJB3:
  Securing an application involves two primary functions: authentication and
  authorization. 

** Authentication
   Authentication is the process of verifying user identify. By authentication
   yourself, you prove that you are who you say you are.

** Authorization
   Authorization is the process of determining whether a user has access to a
   particular resource or task, and it comes into play once a user is
   authenticated. 

* Groups and Roles						      :@EJB3:
  It's impossible for you to code for the specific group names a customer's
  system administrator will choose. Neither should you care about groups. What
  you do care about is what role a particular in a group plays for your
  application.

  [So roles are associated with groups here]

* EJB 3 and Java EE security
  Java EE security is largely based on the Java Authentication and Authorization
  Service (JAAS) API. JAAS essentially separates the authentication system from
  the Java EE application by using well-defined, pluggable API.
  
  The Java EE application need only know how to talk to the JAAS API. The JAAS
  API, in contrast, knows how to talk to underlying authentication systems like
  Lightweight Directory Access Protocol(LDAP), such as Microsoft Active
  Directory or Oracle Internet Directory(OID) using a vendor plug-in. As a
  result, you can easily swap betwen anthetication systems simply by swapping
  JAAS plug-ins without changing any code.

* Declare autheticated roles
  There are many ways to declare autheticated roles:
  1. By using /@DeclareRoles/ annotation at either the method or the class level
     and consists of an array of role names.
  2. Sepcify roles for the entire enterprise application or EJB module through
     deployment descriptors.
  3. If we never declare roles, the container will automatically build a list of
     roles by insepcting the /@RoleAllowed/ annotation. 

     When the application is deployed, the local system admnistrator must map
     each role to groups defined in the runtime security environment.

* Persistence Archive						      :@EJB3:
  Many developer think a separate persistence module is a bad idea because
  entities are supported both outside and inside the container. Considering that
  persistence is inherently a part of any enterprise application, it makes sense
  to support packaging entities with most module types, instead of introducing a
  new module type specialized for packaging entites.
* J2EE archives
  | Type    | Descriptor             | Description                             |
  |---------+------------------------+-----------------------------------------|
  | CAR     | application-client.xml | Thick java client for EJBs              |
  |         |                        |                                         |
  | EAR     | application.xml        | Toplevel enterprise application archive |
  |         |                        |                                         |
  | EJB-JAR | ejb-jar.xml            | EJB archive, contain all kinds of beans |
  |         |                        | may contain an persistent.xml file if   |
  |         |                        | There is any persistence entity         |
  |         |                        |                                         |
  | RAR     | ra.xml                 | Resource adapter archive                |
  |         |                        |                                         |
  | WAR     | web.xml                | Web application archive                 |

* Java EE 5 Automatic Deployment
  Java EE 5 made the deployment descriptor optional, even in the EAR. This is a
  departure from previous version of Java EE, where it was mandatory. The Java
  EE 5.0-compliant application servers deploy by performing automatic detection
  based on a standard naming convention or reding the content of archives; 

* Java EE Class Loader						      :@EJB3:
  There is no Java EE specification provides a standard for class loading, and
  each application server implements class loader in whatever way seems best to
  the vendor. 

  Basically, application server uses a EAR class loader to load all JARs in the
  /lib/ directory that shared between each modules. EJB class loader loads EJBs,
  and it is a child class of EAR class loader, so all classes loaded by EJB
  class loader is visible to EJB classes. The classes loaded by EJB class loader
  are typically visible to the web module in most containers because the WAR
  class loader is a child of EJB class loader.

* Helper Classes Visibility					      :@EJB3:
  - To make helper classes be visible to all modules in the EAR module, just
    package thme in the lib directory which will be automatically visible to all
    modules.

  - If you want to limit the visibility to only a specific EJB-JAR or WAR
    module, you can create an entry in the /Manifest.mf/ file of the module that
    contains a /class-path/ attribute to the JAR file.
  
* Exposing the persistence module				      :@EJB3:
  With EJB3, entities can be used inside either the EJB or web container, or in
  a Java SE application. Thus, entities may be packaged in a standard Java EE
  module such as an EJB-JAR, WAR, or JAR file in the root of the EAR module or
  as a library module in an EAR. When using entities in your applications, you
  have to package entity classes into a Java EE module such as an EJB-JAR or WAR
  of simple JAR files, with a simple deployment descriptor named
  /persistence.xml/.

  If you are using entities within an EJB module, then the EJB classes and
  entities need to be packaged together in the same EJB module. Therefore, the
  EJB-JAR module will contain a persistence.xml file to designate that the
  module contains one or more persistence units. 

* Design Pattern and J2EE					      :@EBJ3:
  Design patterns are generally accepted solutions that typically work for
  common problems. They help avoid "Rediscovering the Wheel Syndrome," and offer
  advice for when and how they should be used. Sun's Java Blueprints Program
  provides a catalog of core design patterns for building Java EE
  applications.


* Domain Model							       :@JPA:
  A /domain model/ is a conceptal image of the problem your system is trying to
  solve. Literally , it is made up of the objects in the "system universe" and
  the relationships or associations between them.

  The critial thing to remmember is that the domain model describes the objects
  and how the objects might relate to each other, but not how a system acts on
  the objects.

* Domain Model Actors
  Domain modeling theory identifies four domain model "actors": 
  - objects
  - relationship 
  - the multiplicity of relationships
  - the optionality of relationships

* Rich vs. Anemic Domain Models					       :@JPA:
  - Anemic domain objects contain only attributes but not behaviors.
  - Rich domain objects contain both attributes and behaviors

* Inheritance and Persistence					       :@JPA:
  If parent class is annotated with @Entity, then all the inherited fields will
  be persistented in an Entity child class. But if parent class is not an
  entity, then the value of the inherited properties will be discarded when
  entity child class is persisted. 

* Field Based Access vs. Property Based Access			       :@JPA:
  + field based access ::
    - defining O/R mapping using fields or instance variable of entity.
    - put annotation on field 

  + property based access ::
    - defining O/R mapping using getter/setter method
    - put annotation on getter method

  Annotation used with a setter are ignored by the persistence provider for
  property-based access

  One caveat in choosing between field and property based persistence is that
  both are one-way streets; you can't mix and match access types in the same
  entity or in any entity inthe POJO hierarchy. 


* Transient Field						       :@JPA:
  You can stop an entity property from being persisted by marking the field or
  getter with the /@Transient/ annotation. 

  Note that defining a field with the transient modifier as we've done with
  generatedName has the same effect as the /@Transient/ annotation.

* Entity Identity
  Every entity of the domain model must be uniquely identifiable. This
  requirement is due partly to the fact that at some point entities must be
  persisted into a uniquely identifiable row in a database table.

** The @Id annotation
   /javax.persistence.Id/ annotation is the simplest way of telling the
   persistence provider where the entity identity is stored. The /@Id/
   annotation marks a field or property as identity for an entity. 

   Use /@Id/ can only identify one field or property as the identity, if you
   want to sepcify multiple fields or properties as identity, then you probably
   have to use /@IdClass/ or /@EmbeddedId/

** The /@IdClass/ annotation
   In effect, the @IdClass annotation enables you to use more than one /@Id/
   annotation in a sensible way. 

   By using /@IdClass/, you may specify multiple /@Id/ field or properties and
   annotate the class with /@IdClass/ to specify how to compare multiple
   identity fields using an external /@IdClass/.

   

** The /@EmbeddedId/
   Using the /@EmbeddedId/ annotation is like moving the /IdClass/ right into
   your entity and using the identity fields nested inside it to store entity
   data. You are not allowed to use /Id/ or /IdClass/ in conjunction with
   /EmbeddedId/.

* The /@Embeddable/ annotation
  The /@Embeedable/ annotation is used to designate persistent object that need
  not have an identify of their own. This is because Embeddable objects are
  identified by the entity objects they are nested inside and never persistend
  or accessed on their own.

  EJB 3 API does not support nested embedded objects. 

* Entity Relationships
  | type of relationship | annotation  |
  |----------------------+-------------|
  | one-to-one           | @OneToOne   |
  | one-to-many          | @OneToMany  |
  | many-to-one          | @ManyToOne  |
  | many-to-many         | @ManyToMany |

** @OneToOne
   The /@OneToOne/ annotation is used to mark uni- and bidirectional one-to-one
   relationships. Although 
* Org Configuration
#+STARTUP: hidestars
#+TAGS: @EJB3 @Ant @AOP
#+TAGS: @DataType @Task
  
